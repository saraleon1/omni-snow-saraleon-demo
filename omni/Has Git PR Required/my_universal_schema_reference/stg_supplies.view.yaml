# Reference this view as my_universal_schema_reference__stg_supplies
schema_label: ""
#This description was pulled from dbt.
description: |
  List of our supply expenses data with basic cleaning and transformation applied.
  One row per supply cost, not per supply. As supply costs fluctuate they receive a new row with a new UUID. Thus there can be multiple rows per supply_id.

schema: my_universal_schema_reference
table_name: STG_SUPPLIES

dimensions:
  supply_uuid:
    sql: '"SUPPLY_UUID"'
    #This description was pulled from dbt.
    description: The unique key of our supplies per cost.

  supply_id:
    sql: '"SUPPLY_ID"'
    format: ID

  product_id:
    sql: '"PRODUCT_ID"'
    format: ID

  supply_name:
    sql: '"SUPPLY_NAME"'

  supply_cost:
    sql: '"SUPPLY_COST"'

  is_perishable_supply:
    sql: '"IS_PERISHABLE_SUPPLY"'

measures:
  count:
    aggregate_type: count

#The info below was pulled from your dbt repository and is read-only.
dbt:
  name: stg_supplies
  target_schema: dbt_sleon_prod
  description: |
    List of our supply expenses data with basic cleaning and transformation applied.
    One row per supply cost, not per supply. As supply costs fluctuate they receive a new row with a new UUID. Thus there can be multiple rows per supply_id.
  config:
    materialized: view
  code: |-
    with

    source as (

        select * from {{ source('dbt_sleon', 'raw_supplies') }}

    ),

    renamed as (

        select

            ----------  ids
            {{ dbt_utils.generate_surrogate_key(['id', 'sku']) }} as supply_uuid,
            id as supply_id,
            sku as product_id,

            ---------- text
            name as supply_name,

            ---------- numerics
            {{ cents_to_dollars('cost') }} as supply_cost,

            ---------- booleans
            perishable as is_perishable_supply

        from source

    )

    select * from renamed
  referenced_by: [ supplies, order_items ]
